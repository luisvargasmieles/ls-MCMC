function [logPiTrace,mse_from_burnIn,mse_stationarity,...
          firstMoment,secondMoment] = MYULA(varargin)
%
% function to sample using proximal MCMC
% algorithm called MYULA (see Durmus, Moulines, and Pereyra, 2018)
%
%%  =========== inputs ====================
%
% 'true_img'                    : true image
%
% 'obs_vector'                  : observation vector
%           
% 'operator'                    : linear operator A
%           
% 'transpose_operator'          : transpose of the linear operator A
%           
% 'operator_transpose_operator' : A^T * A
%           
% 'number_samples_burn_in'      : number of samples to consider in the
%                                 burn-in stage
%
% 'number_samples_stationarity' : number of samples to generate in the
%                                 sampling stage (stationarity)
%
% 'hyperparam_tv'               : value for the total-variation
%                                 hyperparameter
%
% 'moreau_yosida_param'         : Moreau-Yosida approximation parameter
%
% 'sigma'                       : noise level of the likelihood
%
% 'lipschitz_constant_f'        : Lipschitz constant of the likelihood
%
% =========== Outputs ====================
%
% logPiTrace       : log(\pi) scalar value of each generated sample
%
% mse_from_burnIn  : mse between the posterior mean and the true image
%                    (from burn-in)
%
% mse_stationarity : mse between the posterior mean and the true image
%                    (from stationarity)
% 
% firstMoment      : posterior mean estimated from the samples generated
%                    by the MCMC method (in stationarity).
%
% secondMoment     : posterior second moment estimated from the samples
%                    generated by the MCMC method (in stationarity). 
%
% ===================================================

%--------------------------------------------------------------
% Read the input parameters
%--------------------------------------------------------------
for i = 1:2:(length(varargin)-1)
    switch upper(varargin{i})
        case 'TRUE_IMG'
            X          = varargin{i+1};
        case 'OBS_VECTOR'
            Y          = varargin{i+1};
        case 'OPERATOR'
            A          = varargin{i+1};
        case 'TRANSPOSE_OPERATOR'
            At         = varargin{i+1};
        case 'OPERATOR_TRANSPOSE_OPERATOR'
            AtA        = varargin{i+1};
        case 'NUMBER_SAMPLES_BURN_IN'
            nBurnIn    = varargin{i+1};
        case 'NUMBER_SAMPLES_STATIONARITY'
            nSamples   = varargin{i+1};
        case 'HYPERPARAM_TV'
            alpha      = varargin{i+1};
        case 'MOREAU_YOSIDA_PARAM'
            lambda = varargin{i+1};
        case 'SIGMA'
            sigma      = varargin{i+1};
        case 'LIPSCHITZ_CONSTANT_F'
            Lf         = varargin{i+1};
    end
end

%--------------------------------------------------------------
% Main body
%--------------------------------------------------------------

% Gradients functions and Log(Pi) generator function
proxG = @(x) chambolle_prox_TV_stop(x, 'lambda',alpha*lambda,...
                                       'maxiter',20);
ATy = At(Y);
gradF = @(x) (AtA(x) - ATy)/(sigma^2);
gradG = @(x) (x -proxG(x))/lambda;
gradU = @(x) gradF(x) + gradG(x);
logPi = @(x) -(norm(Y-A(x),'fro')^2)/(2*(sigma^2)) -alpha*TVnorm(x);

% MYULA initial conditions
dim_Samples = size(X);
dtMYULA = 1/(Lf + 1/lambda);
XkMYULA = At(Y);
logPiTrace = zeros(1,nSamples + nBurnIn);
logPiTrace(1) = logPi(XkMYULA);

%%% burn-in variables
meanSamplesMYULA_burnIn = XkMYULA; % mean from burn-in stage
mse_from_burnIn = zeros(1,nSamples + nBurnIn);
perc = round(nBurnIn/10); % to show the progress percentage of burn-in

disp("Starting the execution of the MCMC method")
fprintf("Running burn-in stage     \n");
tic;
for i=2:nBurnIn
    Zk = randn(dim_Samples);
    
    % Markov chain update
    XkMYULA = XkMYULA -dtMYULA*gradU(XkMYULA) + sqrt(2*dtMYULA)*Zk;
    
    % save results
    logPiTrace(i)=logPi(XkMYULA);
    
    %%% mean samples burn-in
    meanSamplesMYULA_burnIn = ((i-1)/i)*meanSamplesMYULA_burnIn...
        + (1/i)*(XkMYULA);
    
    %%% mse burn-in
    mse_from_burnIn(i)=immse(meanSamplesMYULA_burnIn,X);

    %%% to show progress of burn-in stage
    if rem(i,perc)==0
        fprintf('\b\b\b\b%2d%%\n', 10*round(i/perc));
    end
end
disp("Burn-in stage finished");
toc

%%% sampling stage variables
% to save the progress of the mse between the mean and the true image
mse_stationarity(nSamples)=0;
% to save the mean (first moment) of each iter
firstMoment = zeros(dim_Samples);
% to save the second moment of each iter
secondMoment = zeros(dim_Samples);
perc = round(nSamples/100); % to show the progress percentage of sampling

fprintf("Running sampling stage     \n");
tic;
for i = 1:nSamples
    % Markov chain update
    Zk = randn(dim_Samples);
    XkMYULA =  XkMYULA - dtMYULA*gradU(XkMYULA) + sqrt(2*dtMYULA)*Zk;
    %%% Record value logPi(Xk) as a scalar summary
    logPiTrace(i+nBurnIn) = logPi(XkMYULA);
    
    %%% mean samples burn-in
    meanSamplesMYULA_burnIn =... 
        ((i + nBurnIn -1)/(i + nBurnIn))...
        *meanSamplesMYULA_burnIn + (1/(i + nBurnIn))*(XkMYULA);
    
    %%% mse burn-in
    mse_from_burnIn(i+nBurnIn)=immse(meanSamplesMYULA_burnIn,X);
    
    %%% mean of the samples in stationarity
    firstMoment = ((i-1)/i)*firstMoment + (1/i)*XkMYULA;
    %%% second moment of the samples in stationarity
    secondMoment = ((i-1)/i)*secondMoment + (1/i)*(XkMYULA.^2);
    %%% mean square error MSE in stationarity
    mse_stationarity(i)=immse(firstMoment,X);
    %%% to save progress of the work
    if rem(i,perc)==0
        fprintf('\b\b\b\b%2d%%\n', round(i/perc));
    end
end
disp("Sampling stage finished");
toc

end