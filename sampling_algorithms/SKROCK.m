function [logPiTrace,mse_from_burnIn,mse_stationarity,...
          firstMoment,secondMoment] = SKROCK(varargin)
%
% function to sample using proximal MCMC
% algorithm called SK-ROCK (see Pereyra, Vargas & Zygalakis, 2020)
%
%%  =========== inputs ====================
%
% 'true_img'                    : true image
%
% 'obs_vector'                  : observation vector
%           
% 'operator'                    : linear operator A
%           
% 'transpose_operator'          : transpose of the linear operator A
%           
% 'operator_transpose_operator' : A^T * A
%           
% 'number_samples_burn_in'      : number of samples to consider in the
%                                 burn-in stage
%
% 'number_samples_stationarity' : number of samples to generate in the
%                                 sampling stage (stationarity)
%
% 'hyperparam_tv'               : value for the total-variation
%                                 hyperparameter
%
% 'moreau_yosida_param'         : Moreau-Yosida approximation parameter
%
% 'sigma'                       : noise level of the likelihood
%
% 'lipschitz_constant_f'        : Lipschitz constant of the likelihood
%
% 'n_stages'                    : number of internal stages of SKROCK
%
% 'perc_dt'                     : fraction of the maximum step-size to use
%
% =========== Outputs ====================
%
% logPiTrace       : log(\pi) scalar value of each generated sample
%
% mse_from_burnIn  : mse between the posterior mean and the true image
%                    (from burn-in)
%
% mse_stationarity : mse between the posterior mean and the true image
%                    (from stationarity)
% 
% firstMoment      : posterior mean estimated from the samples generated
%                    by the MCMC method (in stationarity).
%
% secondMoment     : posterior second moment estimated from the samples
%                    generated by the MCMC method (in stationarity).
% 
% ===================================================

%--------------------------------------------------------------
% Read the input parameters
%--------------------------------------------------------------
for i = 1:2:(length(varargin)-1)
    switch upper(varargin{i})
        case 'TRUE_IMG'
            x          = varargin{i+1};
        case 'OBS_VECTOR'
            y          = varargin{i+1};
        case 'OPERATOR'
            A          = varargin{i+1};
        case 'TRANSPOSE_OPERATOR'
            At         = varargin{i+1};
        case 'OPERATOR_TRANSPOSE_OPERATOR'
            AtA        = varargin{i+1};
        case 'NUMBER_SAMPLES_BURN_IN'
            nBurnIn    = varargin{i+1};
        case 'NUMBER_SAMPLES_STATIONARITY'
            nSamples   = varargin{i+1};
        case 'HYPERPARAM_TV'
            alpha      = varargin{i+1};
        case 'MOREAU_YOSIDA_PARAM'
            lambda = varargin{i+1};
        case 'SIGMA'
            sigma      = varargin{i+1};
        case 'LIPSCHITZ_CONSTANT_F'
            Lipschitz_F = varargin{i+1};
        case 'N_STAGES'
            nStages    = varargin{i+1};
        case 'PERC_DT'
            percDt     = varargin{i+1};
    end
end

%--------------------------------------------------------------
% Main body
%--------------------------------------------------------------

% Gradients functions and Log(Pi) generator function
proxG = @(x) chambolle_prox_TV_stop(x, 'lambda',alpha*lambda,...
                                       'maxiter',20);
ATy = At(y);
gradF = @(x) (AtA(x) - ATy)/(sigma^2);
gradG = @(x) (x -proxG(x))/lambda;
gradU = @(x) gradF(x) + gradG(x);
logPi = @(x) -(norm(y-A(x),'fro')^2)/(2*(sigma^2)) -alpha*TVnorm(x);

% SK-ROCK initial conditions
% First kind Chebyshev function
T_s = @(s,x) cosh(s*acosh(x));

% First derivative Chebyshev polynomial first kind
T_prime_s = @(s,x) s*sinh(s*acosh(x))/sqrt(x^2 -1);

% computing SK-ROCK stepsize given a number of stages
eta=0.05;
denNStag=(2-(4/3)*eta);
rho = ((nStages - 0.5)^2)*denNStag -1.5; % stiffness ratio
dt = percDt*rho/(Lipschitz_F + 1/lambda);
w0=1 + eta/(nStages^2);
w1=T_s(nStages,w0)/T_prime_s(nStages,w0);

%%% precompute the SK-ROCK parameters mu, nu and kappa
mu = zeros(1,nStages);
nu = zeros(1,nStages);
kappa = zeros(1,nStages);
for jj = 1:nStages
    if jj == 1
        mu(jj) = w1/w0;
        nu(jj) = nStages*w1/2;
        kappa(jj) = nStages*(w1/w0);
    else
        mu(jj) = 2*w1*T_s(jj-1,w0)/T_s(jj,w0);
        nu(jj) = 2*w0*T_s(jj-1,w0)/T_s(jj,w0);
        kappa(jj) = 1-nu(jj);
    end
end

% initial conditions
dim_Samples = size(x);
Xk = ATy;
logPiTrace = zeros(1,nSamples + nBurnIn);
logPiTrace(1) = logPi(Xk);

%%% burn-in variables
meanSamplesSKROCK_burnIn = Xk; % mean from burn-in stage
mse_from_burnIn = zeros(1,nSamples + nBurnIn);
perc = round(nBurnIn/10); % to show the progress percentage of burn-in

fprintf("Running burn-in stage     \n");
tic;
for i=2:nBurnIn
    % Markov chain update
    Q=sqrt(2*dt)*randn(dim_Samples);
    Xts= Xk - mu(1)*dt*gradU(Xk + nu(1)*Q) +kappa(1)*Q;
    XtsMinus2 = Xk;
    for js = 2:nStages % deterministic stages
        XprevSMinus2 = Xts;
        Xts=-mu(js)*dt*gradU(Xts) + nu(js)*Xts + kappa(js)*XtsMinus2;
        XtsMinus2=XprevSMinus2;
    end
    Xk=Xts;

    % log PI
    logPiTrace(i)=logPi(Xk);
    
    %%% mean samples burn-in
    meanSamplesSKROCK_burnIn = ((i-1)/i)*meanSamplesSKROCK_burnIn...
        + (1/i)*Xk;
    
    %%% mse burn-in
    mse_from_burnIn(i)=immse(meanSamplesSKROCK_burnIn,x);

    %%% to show progress of burn-in stage
    if rem(i,perc)==0
        fprintf('\b\b\b\b%2d%%\n', 10*round(i/perc));
    end
end
disp("Burn-in stage finished");
toc

%%% sampling variables
% to save the mean (first moment) on each iter
firstMoment = zeros(dim_Samples); % mean of the samples
% to save the progress of the mse between the mean and the true image
mse_stationarity(nSamples)=0;
% to save the second moment of the samples on each iter
secondMoment = zeros(dim_Samples);
perc = round(nSamples/100); % to show the progress (percentage) of sampling

fprintf("Running sampling stage     \n");
tic;
for i=1:nSamples
    Zk = randn(dim_Samples);
    % Markov chain update
    % SKROCK
    Q=sqrt(2*dt)*Zk;
    Xts= Xk - mu(1)*dt*gradU(Xk + nu(1)*Q) +kappa(1)*Q;
    XtsMinus2 = Xk;
    for js = 2:nStages % deterministic stages
        XprevSMinus2 = Xts;
        Xts=-mu(js)*dt*gradU(Xts) + nu(js)*Xts + kappa(js)*XtsMinus2;
        XtsMinus2=XprevSMinus2;
    end
    Xk=Xts;

    % log PI
    logPiTrace(i+nBurnIn)=logPi(Xk);
    %%% mean samples burn-in
    meanSamplesSKROCK_burnIn =... 
        ((i + nBurnIn -1)/(i + nBurnIn))...
        *meanSamplesSKROCK_burnIn + (1/(i + nBurnIn))*Xk;
    
    %%% mse burn-in
    mse_from_burnIn(i+nBurnIn)=immse(meanSamplesSKROCK_burnIn,x);
    %%% mean and mse of samples in stationarity
    firstMoment = ((i-1)/i)*firstMoment + (1/i)*Xk;
    mse_stationarity(i)=immse(firstMoment,x);
    %%% second moment of the samples in stationarity
    secondMoment = ((i-1)/i)*secondMoment + (1/i)*(Xk.^2);
    %%% to save progress of the work
    if rem(i,perc)==0
        fprintf('\b\b\b\b%2d%%\n', round(i/perc));
    end
end
disp("Sampling stage finished");
toc

end